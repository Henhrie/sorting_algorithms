Big O description and sorting algorithms This project is intended to be completed by groups of two students. Each pair should pair programme for at least the necessary portion.

Objectives of Learning By the end of this endeavour, you should be able to explain to anyone, without the use of Google:

There are at least four different sorting algorithms. What is the Big O notation, and how may it be used to assess an algorithm's temporal complexity? How to Choose the Best Sorting Algorithm for a Specific Input What exactly is a stable sorting algorithm? Requirements General The following editors are permitted: vi, vim, and emacs. All of your files will be compiled using gcc on Ubuntu 20.04 LTS with the options specified. -Werror -Wextra -Pedantic -std=gnu89. Every file should conclude with a new line. A README.md file at the root of the project folder is required. The Betty style should be used in your code. Betty-style.pl and Betty-doc.pl will be used to check it. Global variables are not permitted. No more than 5 functions per file are permitted. You are not permitted to use the standard library unless otherwise stated. Any use of functions such as printf, puts, and so on is strictly prohibited. All of your function prototypes should be included in your sort.h header file. Remember to include your header file. Include protect all of your header files. If the size of a list/array is less than 2, it does not need to be sorted. Resources Read or watch the following:

Algorithm for sorting The letter O Animations of sorting algorithms 15 sorting algorithms in 6 minutes (WARNING: The video below may cause seizures or epilepsy. It is not essential for the project because it is merely a humorous visualisation of several sorting methods) David Malan explains CS50 algorithms in detail. Everything about sorting algorithms Structure and Functions of Data You are given the print_array and print_list methods for this project: 
Tasks and requirements for the project This project consists of several tasks, each of which needs you to implement a specific sorting algorithm or examine an algorithm's temporal complexity. For further information, please see the project guidelines and task-specific requirements.
